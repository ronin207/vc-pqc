//! BDEC Proof-of-Concept Layer aligned with the ProSec 2024 specification.
//!
//! The implementation follows the generic construction described in
//! *BDEC: Enhancing Learning Credibility via Post-Quantum Digital Credentials*.
//! It reuses the Loquat signature scheme (Crypto 2024) for long-term keys,
//! pseudonym signatures, and credential signatures, while modelling the zkSNARK
//! proofs mandated by the paper via hash-based commitments so the interfaces
//! match the formal algorithms: `Setup`, `PriGen`, `NymKey`, `CreGen`,
//! `CreVer`, `ShowCre`, `ShowVer`, and `RevCre`.

use crate::loquat::field_utils::F;
use crate::loquat::{
    loquat_setup, loquat_sign, loquat_verify, LoquatPublicParams, LoquatSignature,
};
use crate::snarks::{aurora_prove, aurora_verify, build_loquat_r1cs, AuroraParams, AuroraProof};
use crate::{keygen_with_params, LoquatError, LoquatKeyPair, LoquatResult};
use bincode::Options;
use rand::{distributions::Standard, Rng};
#[cfg(feature = "std")]
use risc0_zkvm::Receipt;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::collections::{HashMap, HashSet};

/// Public parameters for the BDEC layer (`par` in the paper).
#[derive(Debug, Clone)]
pub struct BdecPublicParams {
    pub loquat_params: LoquatPublicParams,
    pub max_attributes: usize,
    pub crs_digest: [u8; 32],
    pub aurora_params: AuroraParams,
}

/// Revocation list storing serialized Loquat public keys (`LR`).
#[derive(Debug, Clone, Default)]
pub struct BdecRevocationList {
    entries: HashSet<Vec<u8>>,
}

impl BdecRevocationList {
    pub fn new() -> Self {
        Self {
            entries: HashSet::new(),
        }
    }

    pub fn add(&mut self, public_key: &[F]) -> LoquatResult<()> {
        let encoded = serialize_public_key(public_key)?;
        self.entries.insert(encoded);
        Ok(())
    }

    pub fn contains(&self, public_key: &[F]) -> LoquatResult<bool> {
        let encoded = serialize_public_key(public_key)?;
        Ok(self.entries.contains(&encoded))
    }
}

/// Complete system state returned by `Setup` (parameters plus revocation list).
#[derive(Debug, Clone)]
pub struct BdecSystem {
    pub params: BdecPublicParams,
    pub revocation_list: BdecRevocationList,
}

/// Pseudonym key pair (`ppk`, `psk`) per the paper.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BdecPseudonymKey {
    pub public: Vec<u8>,
    pub signature: LoquatSignature,
}

/// Placeholder for zkSNARK proofs (hash commitment in the PoC).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BdecCredentialProof {
    pub commitment: [u8; 32],
    pub aurora_proof: AuroraProof,
}

/// Credential record produced by `CreGen`.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BdecCredential {
    pub owner_public_key: Vec<F>,
    pub pseudonym: BdecPseudonymKey,
    pub attributes: Vec<String>,
    pub attribute_hash: [u8; 32],
    pub credential_signature: LoquatSignature,
    pub proof: BdecCredentialProof,
}

/// Bundle generated by `ShowCre`.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BdecShownCredential {
    pub owner_public_key: Vec<F>,
    pub credentials: Vec<BdecCredential>,
    pub verifier_pseudonym: BdecPseudonymKey,
    pub disclosed_attributes: Vec<String>,
    pub disclosure_hash: [u8; 32],
    pub receipt: Receipt,
}

/// Run `Setup`, returning public parameters and an empty revocation list.
pub fn bdec_setup(lambda: usize, max_attributes: usize) -> LoquatResult<BdecSystem> {
    let loquat_params = loquat_setup(lambda)?;
    let mut hasher = Sha256::new();
    hasher.update(b"BDEC_CRS");
    hasher.update(lambda.to_le_bytes());
    hasher.update(max_attributes.to_le_bytes());
    let crs_digest: [u8; 32] = hasher.finalize().into();
    Ok(BdecSystem {
        params: BdecPublicParams {
            loquat_params,
            max_attributes,
            crs_digest,
            aurora_params: AuroraParams::default(),
        },
        revocation_list: BdecRevocationList::new(),
    })
}

/// Generate a long-term Loquat key pair (`PriGen`).
pub fn bdec_prigen(system: &BdecSystem) -> LoquatResult<LoquatKeyPair> {
    keygen_with_params(&system.params.loquat_params)
}

/// Sample a pseudonym public key and sign it with the user's long-term secret (`NymKey`).
pub fn bdec_nym_key(
    system: &BdecSystem,
    user_keypair: &LoquatKeyPair,
) -> LoquatResult<BdecPseudonymKey> {
    let public: Vec<u8> = rand::thread_rng().sample_iter(Standard).take(32).collect();
    let signature = loquat_sign(&public, user_keypair, &system.params.loquat_params)?;
    Ok(BdecPseudonymKey { public, signature })
}

/// Issue a credential and accompanying proof (`CreGen`).
pub fn bdec_issue_credential(
    system: &BdecSystem,
    user_keypair: &LoquatKeyPair,
    pseudonym: &BdecPseudonymKey,
    attributes: Vec<String>,
) -> LoquatResult<BdecCredential> {
    if attributes.len() > system.params.max_attributes {
        return Err(LoquatError::invalid_parameters(
            "too many attributes for credential",
        ));
    }

    let attribute_hash = hash_attributes(&attributes);
    let credential_signature =
        loquat_sign(&attribute_hash, user_keypair, &system.params.loquat_params)?;
    let commitment = credential_commitment(pseudonym, &credential_signature, &attribute_hash)?;

    let (r1cs_instance, r1cs_witness) = build_loquat_r1cs(
        &attribute_hash,
        &credential_signature,
        &user_keypair.public_key,
        &system.params.loquat_params,
    )?;
    let aurora_proof = aurora_prove(&r1cs_instance, &r1cs_witness, &system.params.aurora_params)?;

    Ok(BdecCredential {
        owner_public_key: user_keypair.public_key.clone(),
        pseudonym: pseudonym.clone(),
        attributes,
        attribute_hash,
        credential_signature,
        proof: BdecCredentialProof {
            commitment,
            aurora_proof,
        },
    })
}

/// Verify a credential against public parameters (`CreVer`).
pub fn bdec_verify_credential(
    system: &BdecSystem,
    credential: &BdecCredential,
) -> LoquatResult<bool> {
    if !attributes_match_hash(&credential.attributes, &credential.attribute_hash) {
        return Ok(false);
    }

    if system
        .revocation_list
        .contains(&credential.owner_public_key)?
    {
        return Ok(false);
    }

    if !loquat_verify(
        &credential.attribute_hash,
        &credential.credential_signature,
        &credential.owner_public_key,
        &system.params.loquat_params,
    )? {
        return Ok(false);
    }

    if !loquat_verify(
        &credential.pseudonym.public,
        &credential.pseudonym.signature,
        &credential.owner_public_key,
        &system.params.loquat_params,
    )? {
        return Ok(false);
    }

    let expected_commitment = credential_commitment(
        &credential.pseudonym,
        &credential.credential_signature,
        &credential.attribute_hash,
    )?;
    if expected_commitment != credential.proof.commitment {
        return Ok(false);
    }

    let (r1cs_instance, _) = build_loquat_r1cs(
        &credential.attribute_hash,
        &credential.credential_signature,
        &credential.owner_public_key,
        &system.params.loquat_params,
    )?;
    let proof_ok = aurora_verify(
        &r1cs_instance,
        &credential.proof.aurora_proof,
        &system.params.aurora_params,
        None,
    )?
    .is_some();
    if !proof_ok {
        return Ok(false);
    }
    Ok(true)
}

/// Revoke a user's long-term public key (`RevCre`).
pub fn bdec_revoke(system: &mut BdecSystem, public_key: &[F]) -> LoquatResult<()> {
    system.revocation_list.add(public_key)
}

/// Produce a shown credential bundle with selective disclosure (`ShowCre`).
pub fn bdec_show_credential(
    system: &BdecSystem,
    credentials: &[BdecCredential],
    verifier_pseudonym: BdecPseudonymKey,
    disclosed_attributes: Vec<String>,
    receipt: Receipt,
) -> LoquatResult<BdecShownCredential> {
    if credentials.is_empty() {
        return Err(LoquatError::invalid_parameters(
            "at least one credential is required",
        ));
    }

    let owner_public_key = &credentials[0].owner_public_key;
    for credential in credentials {
        if credential.owner_public_key != *owner_public_key {
            return Err(LoquatError::invalid_parameters(
                "credential does not match user public key",
            ));
        }
        if !bdec_verify_credential(system, credential)? {
            return Err(LoquatError::verification_failure(
                "credential failed verification during selective disclosure",
            ));
        }
    }

    let canonical_disclosure = canonicalise_attributes(&disclosed_attributes)?;
    ensure_disclosure_subset(credentials, &canonical_disclosure)?;
    let disclosure_hash = hash_attributes(&canonical_disclosure);
    Ok(BdecShownCredential {
        owner_public_key: owner_public_key.clone(),
        credentials: credentials.to_vec(),
        verifier_pseudonym,
        disclosed_attributes: canonical_disclosure,
        disclosure_hash,
        receipt,
    })
}

/// Verify a shown credential bundle (`ShowVer`).
pub fn bdec_verify_shown_credential(
    system: &BdecSystem,
    shown: &BdecShownCredential,
    expected_verifier_pseudonym: &[u8],
    image_id: [u32; 8],
) -> LoquatResult<bool> {
    if system.revocation_list.contains(&shown.owner_public_key)? {
        return Ok(false);
    }

    if shown.verifier_pseudonym.public != expected_verifier_pseudonym {
        return Ok(false);
    }

    if !loquat_verify(
        &shown.verifier_pseudonym.public,
        &shown.verifier_pseudonym.signature,
        &shown.owner_public_key,
        &system.params.loquat_params,
    )? {
        return Ok(false);
    }

    for credential in &shown.credentials {
        if credential.owner_public_key != shown.owner_public_key {
            return Ok(false);
        }
        if !bdec_verify_credential(system, credential)? {
            return Ok(false);
        }
    }

    if let Err(_) = ensure_disclosure_subset(&shown.credentials, &shown.disclosed_attributes) {
        return Ok(false);
    }
    let recomputed_hash = hash_attributes(&shown.disclosed_attributes);
    if recomputed_hash != shown.disclosure_hash {
        return Ok(false);
    }

    shown.receipt.verify(image_id).map_err(|err| {
        LoquatError::verification_failure(&format!("receipt verification failed: {err}"))
    })?;

    #[derive(Deserialize)]
    struct ReceiptJournal {
        loquat_valid: bool,
        attribute_count: u32,
        revealed_count: u32,
    }

    let journal: ReceiptJournal =
        shown
            .receipt
            .journal
            .decode()
            .map_err(|err| LoquatError::SerializationError {
                details: format!("failed to decode receipt journal: {err}"),
            })?;

    if !journal.loquat_valid {
        return Ok(false);
    }

    if journal.attribute_count as usize
        != shown
            .credentials
            .get(0)
            .map(|cred| cred.attributes.len())
            .unwrap_or(0)
    {
        return Ok(false);
    }

    if journal.revealed_count as usize != shown.disclosed_attributes.len() {
        return Ok(false);
    }

    Ok(true)
}

fn credential_commitment(
    pseudonym: &BdecPseudonymKey,
    credential_signature: &LoquatSignature,
    attribute_hash: &[u8; 32],
) -> LoquatResult<[u8; 32]> {
    let mut hasher = Sha256::new();
    hasher.update(attribute_hash);
    hasher.update(&pseudonym.public);
    hasher.update(&serialize_signature(&pseudonym.signature)?);
    hasher.update(&serialize_signature(credential_signature)?);
    Ok(hasher.finalize().into())
}

fn hash_attributes(attributes: &[String]) -> [u8; 32] {
    let mut hasher = Sha256::new();
    for attribute in attributes {
        hasher.update(attribute.as_bytes());
        hasher.update(&[0u8]);
    }
    hasher.finalize().into()
}

fn attributes_match_hash(attributes: &[String], expected: &[u8; 32]) -> bool {
    hash_attributes(attributes) == *expected
}

fn canonicalise_attributes(attributes: &[String]) -> LoquatResult<Vec<String>> {
    let mut unique = HashSet::new();
    for value in attributes {
        if !unique.insert(value.clone()) {
            return Err(LoquatError::invalid_parameters(
                "duplicate attribute in disclosure set",
            ));
        }
    }
    let mut ordered: Vec<String> = unique.into_iter().collect();
    ordered.sort();
    Ok(ordered)
}

fn ensure_disclosure_subset(
    credentials: &[BdecCredential],
    disclosed: &[String],
) -> LoquatResult<()> {
    let mut attribute_index: HashMap<&str, usize> = HashMap::new();
    for credential in credentials {
        for attribute in &credential.attributes {
            *attribute_index.entry(attribute).or_insert(0) += 1;
        }
    }

    for attribute in disclosed {
        if !attribute_index.contains_key(attribute.as_str()) {
            return Err(LoquatError::invalid_parameters(
                "disclosed attribute not present in credentials",
            ));
        }
    }
    Ok(())
}

fn serialize_signature(signature: &LoquatSignature) -> LoquatResult<Vec<u8>> {
    bincode_options().serialize(signature).map_err(|err| {
        LoquatError::serialization_error(&format!("failed to encode signature: {err}"))
    })
}

fn serialize_public_key(public_key: &[F]) -> LoquatResult<Vec<u8>> {
    bincode_options().serialize(public_key).map_err(|err| {
        LoquatError::serialization_error(&format!("failed to encode public key: {err}"))
    })
}

fn bincode_options() -> impl Options {
    bincode::DefaultOptions::new()
        .with_fixint_encoding()
        .allow_trailing_bytes()
}
